% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebpmf_log.R
\name{ebpmf_log}
\alias{ebpmf_log}
\title{Fit empirical Bayes Poisson matrix factorization with log link function}
\usage{
ebpmf_log(
  Y,
  l0 = NULL,
  f0 = NULL,
  var_type = "by_col",
  general_control = list(),
  vga_control = list(),
  flash_control = list(),
  sigma2_control = list(),
  init_control = list(),
  verbose = TRUE
)
}
\arguments{
\item{Y}{count data matrix, can be sparse format}

\item{l0, f0}{The background loadings and factors, see the model in ‘Details’.}

\item{var_type}{variance type, "by_row", "by_col" or "constant", see the model in ‘Details’}

\item{general_control}{A list of parameters controlling the behavior of the algorithm. See ‘Details’.}

\item{vga_control}{A list of parameters controlling the behavior of the VGA step. See ‘Details’.}

\item{flash_control}{A list of parameters controlling the behavior of the flash step. See ‘Details’.}

\item{sigma2_control}{A list of parameters controlling the behavior of updating variance. See ‘Details’.}

\item{verbose}{TRUE to print the model fitting progress}
}
\value{
A list of:
 \item{fit_flash:}{fitted flash object}
 \item{elbo:}{evidence lower bound value}
 \item{K_trace:}{trace of number of factors}
 \item{elbo_trace:}{trace of elbo}
 \item{sigma2:}{the variance estimates}
 \item{run_time:}{run time of the algorithm}
}
\description{
Fit empirical Bayes Poisson matrix factorization with log link function
}
\details{
The model is
\deqn{y_{ij}\sim \text{Poisson}(\exp(\mu_{ij})),}
\deqn{\mu_{ij} = l_{i0} + f_{j0} + \sum_k l_{ik}f_{jk} + \epsilon_{ij},}
\deqn{l_{i0}\sim g_{l_0}(\cdot), f_{j0}\sim g_{f_0}(\cdot),}
\deqn{l_{ik}\sim g_{l_k}(\cdot),f_{jk}\sim g_{f_k}(\cdot),}
\deqn{\epsilon_{ij}\sim N(0,\sigma^2_{ij}).}


The \code{init_control} argument is a list in which any of the following
named components will override the default algorithm settings (as
defined by \code{ebpmf_log_init_control_default}):

\describe{
\item{\code{sigma2_init}}{The init value of sigma2}
\item{\code{M_init}}{the initial value for latent M}
\item{\code{init_tol}}{tolerance for initialization}
\item{\code{init_maxiter}}{max iteration for initialization}
\item{\code{verbose}}{TRUE to print initialization progress}
\item{\code{printevery}}{Set a number to determine how often to print progress}
\item{\code{ebpm_init}}{whether use ash_pois for single gene model, as init for vga}
\item{\code{conv_type}}{for init vga fit, use either 'elbo' or 'sigma2abs' for convergence criteria}
\item{\code{n_cores}}{Can utilize more than 1 core to perform initialization, using `mclapply` function.}
\item{\code{flash_est_sigma2}}{TRUE to use flash for initializing sigma2}
\item{\code{log_init_for_non0y}{If TRUE, then for non-0 counts, use log(Y/exp(offset)) as init values}}
\item{\code{n_refit_flash_init}}{The times to refit flash using another seed if no structure was found in initialization}
\item{\code{deal_with_no_init_factor}}{If no factor found in initialization, use 'reduce_var' to reduce init var for flash, or 'flash_dryrun' for not providing the variance}
}

The \code{general_control} argument is a list in which any of the following
named components will override the default algorithm settings (as
defined by \code{ebpmf_log_general_control_default}):
\describe{
\item{\code{batch_size}}{Set this number to 1000 or 10000 or similar to reduce memory usage for vga step by looping subsets of dataset.}
\item{\code{maxiter}}{max iteration allowed.}
\item{\code{conv_tol}}{tolerance for convergence}
\item{\code{printevery}}{How often to print progress over iterations}
\item{\code{verbose}}{TRUE to print progress}
\item{\code{garbage_collection_every}}{How often to perform `gc()` to reduce memory usage}
\item{\code{save_init_val}}{TRUE to return initailization values of latent mu and sigma2}
\item{\code{save_latent_M}}{TRUE to return latent M, its size can be very large}
\item{\code{save_fit_every}}{How often to save intermediate results?}
\item{\code{save_fit_path}}{Where to save intermediate results path}
\item{\code{save_fit_name}}{What is the name to save intermediate results}
}

The \code{flash_control} argument is a list in which any of the following
named components will override the default algorithm settings (as
defined by \code{ebpmf_log_flash_control_default}):

\describe{

\item{\code{ebnm.fn}}{see `?flash`, `ebnm_fn`.}
\item{\code{ebnm.fn.offset}}{The prior for \eqn{l_0}, \eqn{f_0}, if not fixing them.}
\item{\code{loadings_sign}}{see `?flash_greedy_init_default` sign_constraints, must match ebnm.fn}
\item{\code{factors_sign}}{see `?flash_greedy_init_default` sign_constraints, must match ebnm.fn}
\item{\code{fix_l0}}{fix  \eqn{l_0}?}
\item{\code{fix_f0}}{fix  \eqn{f_0}?}
\item{\code{Kmax}}{see `?flash`, `greedy_Kmax`.}
\item{\code{add_greedy_Kmax}}{The Kmax in add_greedy in iterations}
\item{\code{add_greedy_warmstart}}{see `?flash_greedy`}
\item{\code{add_greedy_extrapolate}}{see `?flash_greedy`}
\item{\code{add_greedy_every}}{perform flash_greedy every `add_greedy_every` iterations.}
\item{\code{maxiter_backfitting}}{max iterations for the flash backfitting,see `?flash_backfit`}
\item{\code{backfit_extrapolate}}{see `?flash_backfit`}
\item{\code{backfit_warmstart}}{see `?flash_backfit`}
\item{\code{verbose_flash}}{whether print flash updates}
}

The \code{vga_control} argument is a list in which any of the following
named components will override the default algorithm settings (as
defined by \code{ebpmf_log_vga_control_default}):

\describe{
\item{\code{maxiter_vga}}{max iterations for vga step Newton's method}
\item{\code{vga_tol}}{tolerance for stopping the optimization.}
}

The \code{sigma2_control} argument is a list in which any of the following
named components will override the default algorithm settings (as
defined by \code{ebpmf_log_sigma2_control_default}):

\describe{
\item{\code{est_sigma2}}{whether estimate the variance term or fix it at sigma2_init}
\item{\code{a0,b0}}{Inverse-Gamma(a0,b0) prior on sigma2 for regularization.}
\item{\code{cap_var_mean_ratio}}{only update sigma2 when if var/mean > (1+cap_var_mean_ratio). i.e. when overdispersion is low enough, stop updating sigma2 to boost convergence.}
\item{\code{return_sigma2_trace}}{TRUE to return the sigma2 values along the iterations. internal usage only}
}
}
